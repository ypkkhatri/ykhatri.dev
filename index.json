[{"content":"Introduction When building modern applications, authentication and authorization play a crucial role. Traditionally, these checks happen on the application backend, introducing latency and extra load on your origin servers.\nWith Lambda@Edge, you can run custom auth logic at CloudFront edge locations, stopping unauthorized requests before they ever reach your application or S3 bucket in the first place.\nIn this guide, I’ll walk you through setting up Lambda@Edge to authenticate users, validate JWT tokens issued by Amazon Cognito as a Federated Identity Broker, and handle authorization. This practical, step-by-step approach will help you secure your application globally while keeping latency low by handling authentication and authorization at the edge.\nWhat is Lambda@Edge? Lambda@Edge is an AWS feature that lets you run Lambda functions at CloudFront edge locations worldwide. Instead of processing requests only in a central AWS region, you can intercept and modify requests and responses at the edge — reducing latency and enabling dynamic content manipulation functionality.\nWhy Use Lambda@Edge for Authentication \u0026amp; Authorization? Lower Latency: Auth logic runs closer to the user. Offload Origins: Unauthorized requests never hit your S3 bucket or backend. Global Enforcement: CloudFront edge locations enforce the policy everywhere. Flexible Policies: Validate JWT tokens, API keys, or IP allow lists. How Lambda@Edge Works Lambda@Edge integrates with CloudFront and can be triggered during four lifecycle events:\nViewer Request – when a user requests to CloudFront. Origin Request – before the request is sent to your origin server. Origin Response – after the origin sends a response back to CloudFront. Viewer Response – before CloudFront responds to the user. In this post, we define the process of authentication and authorization at the Viewer Request stage.\nPrerequisites You\u0026rsquo;ll be needing the following before we dive in, note that this post does not cover how to set up Amazon Cognito with an external Identity Provider (IdP). That configuration is assumed to be already in place.\nAn AWS account that has access to Lambda, CloudFront, S3, Amazon Cognito, and IAM. Basic understanding of AWS Lambda and CloudFront distributions. Amazon Cognito must be configured with an external Identity Provider (IdP), (e.g. Microsoft Entra ID). Amazon Cognito should be capable of issuing valid JWT tokens after authenticating against external IdP. You should already have Amazon Cognito User Pool created. With that foundation, we’ll now focus entirely on how to integrate Lambda@Edge with CloudFront and Amazon Cognito to enforce authentication and authorization.\nArchitecture Overview Before diving into the setup, let’s look at how authentication and authorization with Lambda@Edge and Amazon Cognito works at a high level.\nFigure 1: High-level architecture of authentication \u0026amp; authorization with Lambda@Edge with Amazon Cognito\nUser Request → A user tries to access your application via a CloudFront distribution. Lambda@Edge (Viewer Request) → The function intercepts the request before it reaches the origin. Authentication \u0026amp; Authorization → Lambda@Edge forwards incoming requests to Amazon Cognito and that will authenticate against an external Identity Provider (IdP). Once the user successfully signs in, Lambda@Edge validates the JWT token issued Amazon Cognito and authorize the request. If no/invalid token → the user is redirected to log in again. If valid → request continues. Authorized Request → Once authenticated and authorized, CloudFront fetches content from the origin S3 bucket. This flow ensures that only authenticated and authorized users can access your content while still benefiting from CloudFront’s low-latency, globally distributed edge network. Step-by-Step Setup Step 1: Create the IAM role Your Lambda@Edge function needs an execution role with the right permissions and a proper trust relationship.\nIAM Policy (Permissions): Attach the following policy to allow logging to CloudWatch:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Action\u0026#34;: [ \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:logs:us-east-1:*:log-group:/aws/lambda/my-lambda-auth-function:*\u0026#34;, \u0026#34;arn:aws:logs:*:*:log-group:/aws/lambda/us-east-1.my-lambda-auth-function:*\u0026#34; ], \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34; }, ] } Name the role something like LambdaEdgeExecutionRole, and attach this policy. If you need your function to call other AWS services (e.g., SSM, Secrets), you’ll have to extend the policy accordingly. Trust Relationship: Use the following trust relationship, so Lambda can assume the role:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: [ \u0026#34;lambda.amazonaws.com\u0026#34;, \u0026#34;edgelambda.amazonaws.com\u0026#34; ] }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } Step 2: Create a Lambda Function Go to the AWS Lambda Console in the N. Virginia (us-east-1) region.\nCreate a new function (e.g., MyLambdaAuthFunction).\nChoose runtime Node.js (or Python) and select architecture x86_64.\nAttach the IAM role you created earlier with the name LambdaEdgeExecutionRole.\nUpload the function in the form of a zip file, here is the directory structure:\nnode_modules/ lambda_fucntion.mjs Below is the example code for the auth lambda function:\n// lambda_fucntion.mjs \u0026#39;use strict\u0026#39;; import axios from \u0026#39;axios\u0026#39;; import { decode } from \u0026#39;jsonwebtoken\u0026#39;; const COOKIE_KEY_ID_TOKEN = \u0026#39;id_token\u0026#39;; // I assume you already loaded the values based on your design (e.g., SSM) // Start var cognitoAuthDomain = \u0026#34;YOUR_COGNITO_AUTH_DOMAIN\u0026#34;; // e.g., \u0026lt;YUOR_CUSTOM_DOMAIN\u0026gt;.auth.\u0026lt;REGION\u0026gt;.amazoncognito.com var cognitoClientId = \u0026#34;YOUR_COGNITO_CLIENT_ID\u0026#34;; // Cognito Client ID var redirectURI = \u0026#34;YOUR_REDIRECT_URI\u0026#34;; // Your custom domain e.g., Route53 or CloudFront distribution URL var cognitoIdentityProvider = \u0026#34;YOUR_COGNITO_IDENTITY_PROVIDER\u0026#34;; // Name of Identity provider (type OIDC) // END export async function handler(event) { const request = event.Records[0].cf.request; const token = getCookie(request.headers, COOKIE_KEY_ID_TOKEN); if (token) { // Check if token exists try { if (isTokenExpired(token)) { // Check if the token has expired, attempt to refresh it throw new Error(\u0026#34;Token expired\u0026#34;); } else { return request; // Token is valid, allow the request to pass through } } catch (err) { console.error(\u0026#39;Token validation failed:\u0026#39;, JSON.stringify(err)); return cognitoLoginRedirect(); } } const queryParams = getQueryParams(request.querystring); const state = queryParams.state; const code = queryParams.code; // Check: // 1. If the request contains an authorization code, exchange it for tokens and set them as cookies in the response. // 2. If there is no authorization code, redirect the user to the Cognito login. if (code \u0026amp;\u0026amp; state) { const body = { grant_type: \u0026#39;authorization_code\u0026#39;, code, client_id: cognitoClientId, redirect_uri: redirectURI, }; try { const tokens = await requestCognitoToken(body); return setTokenCookiesAndRedirect(tokens); } catch (err) { console.error(\u0026#39;Error retrieving tokens:\u0026#39;, JSON.stringify(err)); return { status: \u0026#39;500\u0026#39;, statusDescription: \u0026#39;Internal Server Error\u0026#39;, body: \u0026#39;Authentication failed: \u0026#39; + JSON.stringify(err), }; } } else { return cognitoLoginRedirect(); } } function setTokenCookiesAndRedirect(tokens) { const idTokenExp = decode(tokens.id_token, { complete: true }).payload.exp; const expiryInSeconds = idTokenExp ? idTokenExp - Math.floor(Date.now() / 1000) : 86400; // Default to 24 hour if no exp in id_token const expiresString = new Date(Date.now() + expiryInSeconds * 1000).toUTCString(); return { status: \u0026#39;302\u0026#39;, statusDescription: \u0026#39;Found\u0026#39;, headers: { location: [{ key: \u0026#39;Location\u0026#39;, value: redirectURI, }], \u0026#39;set-cookie\u0026#39;: Object.entries(tokens).map(([key, value]) =\u0026gt; { return { key: \u0026#39;Set-Cookie\u0026#39;, value: `${key}=${value}; Domain=${getDomain(redirectURI)}; Secure; Path=/; Max-Age=${expiryInSeconds}; Expires=${expiresString};`, }; }), }, }; } function cognitoLoginRedirect() { const state = getRandomString(32); const queryString = Object.entries({ response_type: \u0026#39;code\u0026#39;, client_id: cognitoClientId, identity_provider: cognitoIdentityProvider, scope: [\u0026#39;openid\u0026#39;, \u0026#39;profile\u0026#39;, \u0026#39;email\u0026#39;].join(\u0026#39; \u0026#39;), redirect_uri: redirectURI, state, }) .map(([k, v]) =\u0026gt; `${encodeURIComponent(k)}=${encodeURIComponent(v)}`) .join(\u0026#39;\u0026amp;\u0026#39;); const response = { status: \u0026#39;302\u0026#39;, statusDescription: \u0026#39;Found\u0026#39;, headers: { location: [{ key: \u0026#39;Location\u0026#39;, value: `https://${cognitoAuthDomain}/oauth2/authorize?${queryString}`, }], }, }; return response; } async function requestCognitoToken(body) { const tokensUrl = `https://${cognitoAuthDomain}/oauth2/token`; try { const response = await axios.post(tokensUrl, body, { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, }); return response.data; } catch (err) { console.error(\u0026#39;Error fetching tokens:\u0026#39;, JSON.stringify(err)); throw new Error(`Error fetching tokens: ${err.message}`); } } // Below are the utility functions you need to create, as I have skipped them from the block: // // 1. isTokenExpired(token) // → Extracts `payload.exp` from the JWT and validates expiry. // // 2. getRandomString(length) // → Generates a random alphanumeric string of the given length. // // 3. getQueryParams(queryString) // → Parses query parameters from a URL query string into an object. // // 4. getDomain(url) // → Extracts the base domain (e.g., example.com) from a full URL. // // 5. getCookie(headers, cookieName) // → Extracts the cookie by name from CloudFront request headers. Note: The above code has some redundancies and is written for clarity rather than efficiency. It demonstrates the high-level idea of the authentication and authorization concept with Amazon Cognito and JWT tokens validation. You can optimize it or extend it to support scopes, roles, or custom claims based on your application needs.\nAuthentication \u0026amp; JWT Flow with Lambda@Edge: The following points explain how the request flow works:\nInitial Authentication Request\nThe user accesses your application. Your Lambda@Edge function triggers a request to authenticate the user. The user is redirected to the Identity Provider (IdP) to log in. Receive Authorization Code\nAfter successful login, the IdP returns an authorization code to your application. Exchange Code for JWT Tokens\nYour Lambda function takes the authorization code and requests JWT tokens from Amazon Cognito. Cognito responds with ID token, access token, and refresh token. Store Tokens in Cookie \u0026amp; Redirect\nThe Lambda function stores the received tokens in secure cookies. The user is redirected to the original URL. Subsequent Requests – Token Validation\nWhen the user returns, the Lambda@Edge function sees the JWT tokens in the cookies. It validates the tokens to ensure they are authentic and not expired. Once validated, the request is allowed to pass through to your application. Below is the package.json file for the required packages for the lambda function:\n{ \u0026#34;name\u0026#34;: \u0026#34;my_lambda_auth\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Yougeshwar Khatri\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Layer for Lambda@Edge function\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;zip\u0026#34;: \u0026#34;rm -rf lambda_content.zip \u0026amp;\u0026amp; zip -r lambda_content.zip ./node_modules ./lambda_function.mjs\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;axios\u0026#34;: \u0026#34;^1.11.0\u0026#34;, \u0026#34;jsonwebtoken\u0026#34;: \u0026#34;^9.0.2\u0026#34; } } Build and Package: Run the following commands to install dependencies and create a zip file for deployment\n# Install project dependencies npm install # Build and create a zip package npm run zip Step 3: Create an S3 Bucket (Origin) Create an S3 bucket (e.g., MyLambdaEdgeAuthBucket). Upload sample files (e.g., index.html). Keep the bucket private. Step 4: Create a CloudFront Distribution Create a new distribution with the name MyDistribution\nSet your S3 bucket as the origin.\nSave the distribution.\nEdit the distribution again to add the behavior\nCreate behavior\nPath pattern: Default (*) Origin: Select S3 bucket origin Viewer protocol policy: Enable Redirect HTTP to HTTPS. Allowed HTTP methods: GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE Function associations: Viewer request Function type: Lambda@Edge Function ARN with version # It will be updated in next step Step 5: Deploy Lambda@Edge Open your Lambda function in us-east-1. Select Actions → Deploy to Lambda@Edge. Attach it to your CloudFront distribution on the Viewer Request event, and that will update the version in CloudFront distribution behavior. Deploy. Step 6: Test Your Setup Testing auth with Amazon Cognito requires a browser flow because tokens are issued after a successful login.\nOpen a browser and access your custom domain or CloudFront URL (e.g., https://d1234abcdef.cloudfront.net/). If the user is not authenticated, the application should redirect them to external IdP login page through Amazon Cognito. After login, Amazon Cognito issues the JWT tokens and redirects back to your CloudFront URL with the tokens included in secure cookies. Lambda@Edge validates the token at the Viewer Request stage: If valid → the request passes and content is served. If invalid/expired → the user sees a 403 Forbidden response. Logging \u0026amp; Debugging Debugging Lambda@Edge is often tricky, because logs are not tied to the AWS region where your Lambda@Edge is deployed (us-east-1). Instead:\nCloudWatch log groups are always created in request origin region, not in N. Virginia (us-east-1). The log groups appear in the AWS region closest to the request’s origin (e.g., if a user requests from Germany, logs will be in eu-central-1).\nThe log group follows the naming format:\n/aws/lambda/us-east-1.\u0026lt;function-name\u0026gt; So if your function is called MyLambdaAuthFunction, the logs will be stored in the closest request\u0026rsquo;s origin region under:\n/aws/lambda/us-east-1.MyLambdaAuthFunction Limitations Keep these in mind when designing your auth logic:\nDeployment Region – Functions must be created in us-east-1. No Environment Variables – Use hard-coded values or versions or SSM. Package Size – Max 50 MB uncompressed, 1 MB inline zip. Execution Timeouts – 5s for viewer events, 30s for origin events. Runtimes – Only Node.js and Python are supported. Architecture – Only x86_64 (no ARM/Graviton). File System – Read-only /tmp directory, max 512 MB. Limited IAM Access – Avoid heavy AWS API calls. Conclusion By moving auth checks to the edge, you:\nBlock unauthorized requests early. Reduce load on your backend. Improve latency and scalability. Lambda@Edge is not a full replacement for centralized identity providers, but it’s an excellent way to add a first line of defense at the network edge.\nStart small — implement a static header check — then expand into JWT validation, deeper Cognito integration. Later, you can build on this with the refresh_token concept for more advanced scenarios.\nReferences Below are some useful resources and references that inspired this guide and provide additional context on Lambda@Edge, Amazon Cognito and external IdP (Azure AD) auth process.\nhttps://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-at-edge-function-restrictions.html https://docs.aws.amazon.com/cognito/latest/developerguide/token-endpoint.html https://docs.aws.amazon.com/cognito/latest/developerguide/federation-endpoints.html https://docs.aws.amazon.com/singlesignon/latest/userguide/how-to-connect-idp.html https://aws.amazon.com/blogs/networking-and-content-delivery/authorizationedge-using-cookies-protect-your-amazon-cloudfront-content-from-being-downloaded-by-unauthenticated-users/ ","permalink":"https://ykhatri.dev/posts/step-by-step-guide-setting-up-lambda-at-edge-for-authentication-and-authorization-with-amazon-cognito/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWhen building modern applications, \u003cstrong\u003eauthentication and authorization\u003c/strong\u003e play a crucial role. Traditionally, these checks happen on the application backend, introducing \u003cstrong\u003elatency\u003c/strong\u003e and extra load on your origin servers.\u003c/p\u003e\n\u003cp\u003eWith \u003cstrong\u003eLambda@Edge\u003c/strong\u003e, you can run custom \u003cstrong\u003eauth logic at CloudFront edge locations\u003c/strong\u003e, stopping unauthorized requests before they ever reach your application or S3 bucket in the first place.\u003c/p\u003e\n\u003cp\u003eIn this guide, I’ll walk you through \u003cstrong\u003esetting up Lambda@Edge to authenticate users, validate JWT tokens issued by Amazon Cognito as a Federated Identity Broker, and handle authorization\u003c/strong\u003e. This practical, step-by-step approach will help you secure your application globally while keeping latency low by handling authentication and authorization at the edge.\u003c/p\u003e","title":"Step-by-Step Guide: Setting Up Lambda@Edge for Authentication \u0026 Authorization with Amazon Cognito"},{"content":" I have been working in the IT industry for over 12 years, specializing in designing and developing scalable cloud-native applications. My expertise lies in leveraging AWS services alongside technologies such as Java, Go, and Spring Boot to create robust and efficient solutions. I hold multiple AWS certifications, including the HashiCorp Certified Terraform Associate, and have earned a master’s degree in computer science from Germany. Here are my key areas of expertise:\nCloud Industry Expertise (AWS, Azure, GCP) Infrastructure as Code (Terraform, CloudFormation, \u0026amp; AWS CDK) Programming Languages (Java, Go, Node.js, etc.) DevOps Automation \u0026amp; CI/CD Pipelines Cloud Security \u0026amp; Best Practices Containerization \u0026amp; Kubernetes Scalable and Resilient Cloud Architectures You can view my professional certifications here.\nMy professional journey has included collaborations with prominent organizations such as Volkswagen (VW) and MAN Truck \u0026amp; Bus SE, where I contributed to building and optimizing high-performance, cloud-native infrastructures for data-intensive applications. Additionally, I’ve worked with AWS on internal projects, tackling complex challenges and delivering innovative solutions.\nI’m passionate about microservices architecture and domain-driven design, consistently striving to deliver high-quality, scalable solutions that align with business objectives. With a strong focus on automation and performance, I’m committed to solving intricate challenges while staying on the cutting edge of technology.\nWhat I’m Learning I believe in continuous growth and expanding my expertise. Currently, I’m:\nDeepening my knowledge of Kubernetes and preparing for relevant certifications. Pursuing additional AWS certifications to strengthen my cloud expertise. Enhancing my understanding of Microsoft Azure, focusing on advanced cloud services and architectures. By combining my experience with a dedication to lifelong learning, I aim to deliver innovative solutions that drive business success and exceed expectations. You can reach out me via this contact form here.\n","permalink":"https://ykhatri.dev/about/","summary":"\u003cdiv class=\"image-with-text\"\u003e\n  \u003cdiv class=\"image-container\"\u003e\n    \u003cimg src=\"/images/about-picture.webp\" alt=\"Adventure trip\" /\u003e\n  \u003c/div\u003e\n  \u003cdiv class=\"text-container\"\u003e\n    \nI have been working in the IT industry for over 12 years, specializing in designing and developing scalable cloud-native applications. My expertise lies in leveraging AWS services alongside technologies such as Java, Go, and Spring Boot to create robust and efficient solutions. I hold multiple AWS certifications, including the HashiCorp Certified Terraform Associate, and have earned a master’s degree in computer science from Germany.\n\n  \u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eHere are my key areas of expertise:\u003c/p\u003e","title":"About"},{"content":"The certifications listed here reflect my commitment to professional growth and staying current in a fast-evolving industry. While these credentials validate my expertise, they complement hands-on experience gained through real-world application.\nCertifications play a key role in my career by enhancing my skills and providing formal recognition of my proficiency. They serve as a benchmark, demonstrating my ability to apply best practices and stay competitive in my field.\nThese certifications represent both knowledge and practical skills, empowering me to tackle challenges and deliver impactful solutions. Below is a list of my certifications, including issuing organizations, completion dates, and relevant links.\n","permalink":"https://ykhatri.dev/certs/","summary":"\u003cp\u003eThe certifications listed here reflect my commitment to professional growth and staying current in a fast-evolving industry. While these credentials validate my expertise, they complement hands-on experience gained through real-world application.\u003c/p\u003e\n\u003cp\u003eCertifications play a key role in my career by enhancing my skills and providing formal recognition of my proficiency. They serve as a benchmark, demonstrating my ability to apply best practices and stay competitive in my field.\u003c/p\u003e\n\u003cp\u003eThese certifications represent both knowledge and practical skills, empowering me to tackle challenges and deliver impactful solutions. Below is a list of my certifications, including issuing organizations, completion dates, and relevant links.\u003c/p\u003e","title":"Certifications"},{"content":"You can fill the below form to reach out to me:\n","permalink":"https://ykhatri.dev/contact/","summary":"\u003cp\u003eYou can fill the below form to reach out to me:\u003c/p\u003e","title":"Contact"},{"content":"Who I Am Welcome! My name is Yougeshwar Khatri, and this is my personal website. I am committed to protecting your privacy. This Privacy Policy explains what data I collect, how I use it, and your rights regarding your data.\nData Collection This website collects minimal data to ensure your privacy and provide insights to help me improve the site\u0026rsquo;s performance:\nCloudflare Web Analytics: I use Cloudflare Web Analytics to measure traffic and performance on this website. Cloudflare Web Analytics is a privacy-first analytics tool that does not track individual users, use cookies, or collect personal data. Your Privacy I respect your privacy and ensure that no personally identifiable information is collected or stored through this website. The analytics used here are strictly for understanding visitor behavior and improving the content and performance of the site.\nContact Me If you have any questions or concerns about this Privacy Policy, please contact me via contact form.\nUpdates This Privacy Policy was last updated on January 23, 2025.\n","permalink":"https://ykhatri.dev/privacy-policy/","summary":"\u003ch2 id=\"who-i-am\"\u003eWho I Am\u003c/h2\u003e\n\u003cp\u003eWelcome! My name is Yougeshwar Khatri, and this is my personal website. I am committed to protecting your privacy. This Privacy Policy explains what data I collect, how I use it, and your rights regarding your data.\u003c/p\u003e\n\u003ch2 id=\"data-collection\"\u003eData Collection\u003c/h2\u003e\n\u003cp\u003eThis website collects minimal data to ensure your privacy and provide insights to help me improve the site\u0026rsquo;s performance:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCloudflare Web Analytics\u003c/strong\u003e:\nI use \u003ca href=\"https://www.cloudflare.com/en-gb/web-analytics/\"\u003eCloudflare Web Analytics\u003c/a\u003e to measure traffic and performance on this website. Cloudflare Web Analytics is a privacy-first analytics tool that does not track individual users, use cookies, or collect personal data.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"your-privacy\"\u003eYour Privacy\u003c/h2\u003e\n\u003cp\u003eI respect your privacy and ensure that no personally identifiable information is collected or stored through this website. The analytics used here are strictly for understanding visitor behavior and improving the content and performance of the site.\u003c/p\u003e","title":"Privacy Policy"},{"content":"","permalink":"https://ykhatri.dev/contact-thankyou/","summary":"","title":"Thank you"}]