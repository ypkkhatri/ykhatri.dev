[{"content":"Introduction AWS App Runner makes it incredibly easy to deploy and scale web applications directly from your code repository or container image ‚Äî no infrastructure management required. It‚Äôs a great fit for developers who want simplicity without giving up the power of AWS.\nBut things start to get tricky when you want to securely connect App Runner to other AWS services inside a private VPC ‚Äî especially when you need to expose your backend through Amazon API Gateway.\nBy default, App Runner services are public-facing, and API Gateway communicates over the internet. While that works fine for basic setups, production environments often demand private connectivity, where all traffic stays within AWS‚Äôs internal network for security, compliance, or performance reasons.\nIn this guide, we‚Äôll go beyond the usual public setup and walk through how to:\nConnect Amazon API Gateway to your App Runner service through a private network path. Use VPC Link, Network Load Balancer (NLB), and App Runner VPC Endpoint to securely route traffic. Avoid common networking pitfalls around subnets, DNS, and permissions. Build a scalable, secure architecture suitable for production environments. By the end of this post, you‚Äôll have a working, private integration between API Gateway and App Runner ‚Äî a clean, secure pattern that combines the simplicity of App Runner with the control and power of AWS networking.\nUnderstanding the Architecture Before jumping into the implementation, it‚Äôs important to understand how each AWS service fits together in this design.\nFigure 1: Private integration between Amazon API Gateway and AWS App Runner using VPC Link, NLB, and App Runner VPC Endpoint.\nThe request flow works as follows:\nClient ‚Üí API Gateway The client sends an HTTP request to the API Gateway endpoint. This can be a public endpoint (secured with authentication) or a private API within your organization.\nAPI Gateway ‚Üí VPC Link API Gateway uses a VPC Link to establish a private connection to resources inside your VPC. This avoids exposing your backend to the internet.\nVPC Link ‚Üí Network Load Balancer (NLB) The VPC Link routes requests to a Network Load Balancer, which acts as the bridge between API Gateway and internal services. The NLB is required because VPC Link integrations must target a load balancer rather than an EC2 instance or endpoint directly.\nNLB ‚Üí App Runner VPC Endpoint The NLB forwards traffic to the App Runner VPC Endpoint ‚Äî a private endpoint that connects your VPC to your App Runner service securely.\nApp Runner VPC Endpoint ‚Üí App Runner Service Finally, the traffic reaches your App Runner service running inside AWS‚Äôs managed environment. Since all components are privately connected, there‚Äôs no public internet exposure at any stage.\nThis design ensures that your API Gateway communicates privately with App Runner, maintaining full control over inbound and outbound traffic. It‚Äôs a clean and secure pattern ideal for production workloads, regulated environments, or internal APIs.\nThe Challenge When working with AWS App Runner, one of its biggest strengths ‚Äî simplicity ‚Äî can also become a limitation once you step into more advanced architectures.\nBy default, every App Runner service exposes a public endpoint, and any client or service can reach it over the internet (unless restricted via IAM or custom authentication). That‚Äôs fine for simple apps or prototypes, but in most production setups, you need your backend to:\nCommunicate only within a private AWS network Be accessible only through controlled entry points (like API Gateway) Avoid public exposure for compliance or security reasons This is where the challenge begins.\nAPI Gateway cannot directly integrate with App Runner over private connectivity. Unlike services such as ECS or Lambda, there‚Äôs no built-in ‚Äúprivate integration‚Äù option. Even though App Runner now supports VPC Endpoints, these endpoints can‚Äôt be called directly by API Gateway ‚Äî they must be reached through a VPC Link, which in turn requires a Network Load Balancer (NLB) as a target.\nSo the main puzzle looks like this:\nHow can we connect API Gateway to a private App Runner service, without exposing anything publicly, while keeping the setup clean and maintainable?\nThe answer lies in chaining the components together:\nAPI Gateway ‚Üí VPC Link ‚Üí Network Load Balancer (NLB) ‚Üí App Runner VPC Endpoint ‚Üí App Runner Service\nEach layer serves a specific purpose in keeping the communication private, scalable, and secure.\nIn the next section, we‚Äôll walk through how to implement this step by step using AWS CDK Python, highlighting key configurations along the way ‚Äî and link to a complete example repository for you to explore.\nThe Solution ‚Äî Connecting API Gateway and App Runner Privately Now that we understand the architecture and the networking challenge, let‚Äôs look at how to bring everything together. We‚Äôll use AWS CDK Python to provision all components, following the secure flow:\nAPI Gateway ‚Üí VPC Link ‚Üí Network Load Balancer (NLB) ‚Üí App Runner VPC Endpoint ‚Üí App Runner Service Each layer plays a distinct role in ensuring private communication inside your AWS environment.\n1. Create the VPC, Security Group, and App Runner VPC Endpoint Start by creating a VPC with private subnets and a security group that allows traffic between the Network Load Balancer (NLB) and the App Runner VPC Endpoint. Next, set up the App Runner VPC Endpoint to enable private connectivity between your VPC and the App Runner service ‚Äî this ensures all communication stays internal, without exposing traffic to the public internet.\nvpc = ec2.Vpc( self, \u0026#34;VPCId\u0026#34;, vpc_name=\u0026#34;my-vpc\u0026#34;, subnet_configuration=[ ec2.SubnetConfiguration( name=\u0026#34;my-private-subnet\u0026#34;, subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS, cidr_mask=24, ) ], nat_gateways=0 # We don\u0026#39;t need the NAT gateway ) security_group = ec2.SecurityGroup( self, \u0026#34;SecurityGroupId\u0026#34;, security_group_name=\u0026#34;security-group\u0026#34;, vpc=vpc, allow_all_outbound=True, ) security_group.add_ingress_rule( peer=security_group, connection=ec2.Port.all_traffic(), description=\u0026#34;Allow all traffic within the security group\u0026#34; ) vpc_apprunner_requests_endpoint = ec2.InterfaceVpcEndpoint( self, \u0026#34;AppRunnerRequestsEndpointId\u0026#34;, vpc=vpc, service=ec2.InterfaceVpcEndpointAwsService.APP_RUNNER_REQUESTS, subnets=ec2.SubnetSelection(subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS), security_groups=[security_group], private_dns_enabled=False, ) 2. Create the Network Load Balancer With the App Runner VPC Endpoint in place, the next step is to create a Network Load Balancer (NLB) inside your VPC which will be used connect to API Gateway via a VPC Link.\nSince App Runner VPC Endpoints use dynamically assigned ENIs, the NLB target group must resolve the private IP addresses of these interfaces. This ensures that traffic from API Gateway reaches the App Runner service securely and privately.\nKey points to keep in mind:\nThe NLB target group will point to the App Runner VPC Endpoint network interfaces IP addresses. Use TCP protocol for the target group, since App Runner listens for HTTP traffic internally. Ensure security groups and subnet configurations allow traffic from the NLB to the App Runner service. Here‚Äôs a concise AWS CDK snippet showing the setup:\neni_ipaddress_resolver = EniIpAddressResolver( self, \u0026#34;EniIpAddressResolverId\u0026#34;, network_interface_ids=vpc_apprunner_requests_endpoint_eni_ids ) app_runner_vpc_endpoint_ips = eni_ipaddress_resolver.get_ip_addresses() nlb_apprunner = elbv2.NetworkLoadBalancer( self, \u0026#34;NLBAppRunnerId\u0026#34;, load_balancer_name=\u0026#34;nlb-app-runner\u0026#34;, vpc=vpc, vpc_subnets=ec2.SubnetSelection( subnet_type=ec2.SubnetType.PRIVATE_WITH_EGRESS ), security_groups=[security_group], internet_facing=False, cross_zone_enabled=True, enforce_security_group_inbound_rules_on_private_link_traffic=False, ) nlb_network_group = elbv2.NetworkTargetGroup( self, \u0026#34;NLBAppRunnerTargetGroupId\u0026#34;, target_group_name=\u0026#34;my-nlb-app-runner-tg\u0026#34;, vpc=vpc, port=443, protocol=elbv2.Protocol.TCP, target_type=elbv2.TargetType.IP, targets=[elbv2targets.IpTarget( ip) for ip in app_runner_vpc_endpoint_ips] ) nlb_listener = nlb_apprunner.add_listener( \u0026#34;NLBAppRunnerListenerId\u0026#34;, default_target_groups=[nlb_network_group], port=443, protocol=elbv2.Protocol.TCP ) üí° Note: The app_runner_vpc_endpoint_ips should be dynamically resolved from the ENIs of your App Runner VPC Endpoint. The AWS CDK code for class EniIpAddressResolver in the example GitHub repo handles this automatically.\nThis setup allows API Gateway to route requests through the VPC Link ‚Üí NLB ‚Üí App Runner VPC Endpoint ‚Üí App Runner service, keeping all traffic within the private network.\n3. Configure App Runner Service in a VPC Once your VPC and NLB are ready, it‚Äôs time to configure the App Runner service to run inside your private network.\nKey steps:\nAttach the VPC Connector Ensure your App Runner service uses a VPC Connector pointing to the private subnets of your VPC. This allows the service to receive traffic through the NLB and communicate privately with other resources in the VPC. Associate Security Groups Use a security group that allows inbound traffic from the NLB and outbound traffic to any other required resources (databases, internal APIs, etc.). Private DNS and Networking App Runner services inside a VPC use private DNS names and ENIs, which are automatically resolved when registering with the NLB target group. Create the VPC Ingress Connection The VPC Ingress Connection is required for API Gateway or NLB to send traffic to a private App Runner service. It establishes the secure link between the App Runner service and your VPC. Here‚Äôs a concise CDK snippet illustrating the setup:\napprunner_vpc_connector = apprunner.CfnVpcConnector( self, \u0026#34;AppRunnerVpcConnectorId\u0026#34;, vpc_connector_name=\u0026#34;my-arvpcconn\u0026#34;, subnets=vpc_subnet_ids, security_groups=security_group_ids, ) apprunner_backend_api_service = apprunner.CfnService( self, \u0026#34;AppRunnerBackendAPIServiceId\u0026#34;, source_configuration=apprunner.CfnService.SourceConfigurationProperty( authentication_configuration=apprunner.CfnService.AuthenticationConfigurationProperty( access_role_arn=app_runner_role.role_arn ), image_repository=apprunner.CfnService.ImageRepositoryProperty( image_identifier=\u0026#34;my-app-image:latest\u0026#34;, image_repository_type=\u0026#34;ECR\u0026#34; ) ), network_configuration=apprunner.CfnService.NetworkConfigurationProperty( ingress_configuration=apprunner.CfnService.IngressConfigurationProperty( is_publicly_accessible=False ), egress_configuration=apprunner.CfnService.EgressConfigurationProperty( egress_type=\u0026#34;VPC\u0026#34;, vpc_connector_arn=apprunner_vpc_connector.attr_vpc_connector_arn ), ), health_check_configuration=apprunner.CfnService.HealthCheckConfigurationProperty( path=\u0026#34;/\u0026#34;, ), ) apprunner_vpc_ingress_connection = apprunner.CfnVpcIngressConnection( self, \u0026#34;AppRunnerVpcIngressConnectionId\u0026#34;, vpc_ingress_connection_name=\u0026#34;my-arvpcincon\u0026#34;, service_arn=apprunner_backend_api_service.attr_service_arn, ingress_vpc_configuration=apprunner.CfnVpcIngressConnection.IngressVpcConfigurationProperty( vpc_id=vpc.vpc_id, vpc_endpoint_id=vpc_apprunner_requests_endpoint.vpc_endpoint_id ) ) üí° Tip: Your App Runner service now has full private connectivity, enabling API Gateway to route requests securely via the NLB and VPC Link.\n4. Configure API Gateway Private Integration With the App Runner service fully private and connected to the VPC via the VPC Connector and VPC Ingress Connection, the final piece is to configure API Gateway so that it can securely route requests to your backend.\nCreate a VPC Link The VPC Link connects API Gateway to your Network Load Balancer (NLB) inside the private VPC. API Gateway uses this link to send traffic over the private network rather than the public internet. Configure API Gateway Routes Define the routes or methods for your API. Each route uses the existing VPC Link to forward requests to the NLB, which then reaches the App Runner service. Security and Access Optionally, add authorization (Cognito, IAM, or Lambda authorizers) to your API Gateway endpoints. Ensure security group rules allow traffic from the NLB to the App Runner service. Here‚Äôs a concise CDK snippet showing the integration:\nvpc_link = apigateway.VpcLink( self, \u0026#34;ApiGatwayVpcLinkId\u0026#34;, description=\u0026#34;VPC Link for App Runner NLB\u0026#34;, vpc_link_name=\u0026#34;my-nlb-vpc-link\u0026#34;, targets=[nlb_apprunner] ) apigateway_restapi = apigateway.RestApi( self, \u0026#34;ApiGatwayOpdRestApiId\u0026#34;, ... ) apprunner_integration = apigateway.Integration( type=apigateway.IntegrationType.HTTP_PROXY, integration_http_method=\u0026#34;ANY\u0026#34;, options=apigateway.IntegrationOptions( connection_type=apigateway.ConnectionType.VPC_LINK, vpc_link=vpc_link, passthrough_behavior=apigateway.PassthroughBehavior.WHEN_NO_MATCH, request_parameters={ \u0026#34;integration.request.path.proxy\u0026#34;: \u0026#34;method.request.path.proxy\u0026#34; }, ), uri=f\u0026#34;https://{apprunner_vpc_ingress_connection.attr_domain_name}\u0026#34; + \u0026#34;/{proxy}\u0026#34;, ) restapi_apprunner_app_resource = apigateway_restapi.root.add_proxy( any_method=True, default_integration=apprunner_integration, default_method_options=apigateway.MethodOptions( api_key_required=True, # As its enabled you need to setup the key separately request_parameters={ \u0026#34;method.request.path.proxy\u0026#34;: True }, ) ) ‚ö†Ô∏è Important These request_parameters are crucial for proxy integrations to work correctly:\n\u0026quot;integration.request.path.proxy\u0026quot;: \u0026quot;method.request.path.proxy\u0026quot; ensures the path is correctly forwarded from API Gateway to the NLB. \u0026quot;method.request.path.proxy\u0026quot;: True enables the API Gateway route to accept any path parameter dynamically. Missing these will cause the proxy route to fail or return 403/404 errors.\nThis ensures that your App Runner backend is fully private, with requests securely routed through API Gateway without exposing anything publicly. All traffic now flows privately through: Client ‚Üí API Gateway ‚Üí NLB ‚Üí App Runner VPC Endpoint ‚Üí App Runner Service\nCommon Pitfalls \u0026amp; Troubleshooting Even with a clear architecture, integrating API Gateway with App Runner in a private VPC can be tricky. Here are the most common issues and tips to avoid them:\nENI IP Address Resolution App Runner VPC Endpoints use dynamically assigned network interfaces (ENIs). The Network Load Balancer must register these IPs as targets. ‚úÖ Tip: Use the CDK or your IaC tool to automatically fetch and register the ENI IPs; manually using static IPs can break if App Runner scales or changes. Security Groups and Subnet Configuration Ensure security groups allow: NLB ‚Üí App Runner VPC Endpoint traffic (inbound) App Runner ‚Üí other required services (outbound) Private subnets must have route tables allowing internal communication between NLB and App Runner. üîπ Common mistake: forgetting inbound rules for the NLB ‚Üí App Runner path. API Gateway Proxy Integration Parameters As highlighted earlier, these request_parameters are critical:\n\u0026#34;integration.request.path.proxy\u0026#34;: \u0026#34;method.request.path.proxy\u0026#34; \u0026#34;method.request.path.proxy\u0026#34;: True Missing or misconfigured parameters can cause 403, 404, or 502 errors. Always verify them in your code.\nDNS and Private Connectivity App Runner services in a VPC use private DNS. NLB target groups must resolve these private DNS names to ENI IP addresses. ‚ùó If DNS fails, traffic will not reach App Runner ‚Äî double-check private DNS and subnet connectivity. Testing and Logging Use Postman, curl, or API Gateway test console to validate requests. Enable CloudWatch logs on API Gateway and App Runner for troubleshooting. Enable AWS X-Ray tracing for both API Gateway and App Runner Service to get end-to-end visibility of requests, latency, and potential bottlenecks. Confirm that traffic flows: Client ‚Üí API Gateway ‚Üí NLB ‚Üí App Runner VPC Endpoint ‚Üí App Runner Service üí° Pro Tip: Most issues in private integration setups come from networking or security group misconfigurations, so verify your VPC, subnets, and SG rules before troubleshooting code.\nConclusion \u0026amp; Next Steps In this guide, we explored how to set up Amazon API Gateway as a front door for an AWS App Runner service in a private VPC. By combining VPC Links, Network Load Balancer, and App Runner VPC Endpoints, we achieved a secure, fully private integration that keeps all traffic inside your AWS network.\nKey Takeaways App Runner services can now operate privately, avoiding public exposure. API Gateway VPC Links enable private connectivity to internal resources like NLB and App Runner endpoints. Proper configuration of security groups, subnets, and proxy integration parameters is critical for a working setup. AWS CDK (or other IaC tools) simplifies provisioning and dynamically resolves App Runner ENI IP addresses. AWS X-Ray (if enabled) and CloudWatch logs help trace requests end-to-end and troubleshoot networking issues. Next Steps Explore authorization options on API Gateway (Cognito, IAM, or Lambda authorizers) to control access to your private backend. üîπ Tip: You can refer to my previous blog on Lambda@Edge with Amazon Cognito for detailed guidance on integrating authentication and JWT validation: [üîó Step-by-Step Guide: Setting Up Lambda@Edge for Authentication \u0026amp; Authorization with Amazon Cognito] Automate deployment using CI/CD pipelines for reproducible setups. Experiment with scaling App Runner services while maintaining private integration. Check out the example repository for the full AWS CDK Python implementation: üîó GitHub Example Repo Link Comment on below if you‚Äôd like a Terraform version of this setup! This architecture provides a secure, scalable, and maintainable pattern for exposing App Runner services through API Gateway without public internet exposure ‚Äî ideal for internal APIs, regulated environments, or production workloads.\nReferences The following resources provided valuable insights and context for this guide, covering AWS App Runner, API Gateway private integrations, VPC connectivity:\nhttps://www.youtube.com/watch?v=H5OKe8jXnX0 https://repost.aws/knowledge-center/api-gateway-500-error-vpc https://docs.aws.amazon.com/elasticloadbalancing/latest/network/load-balancer-security-groups.html https://aws.amazon.com/blogs/compute/understanding-vpc-links-in-amazon-api-gateway-private-integrations/ ","permalink":"https://ykhatri.dev/posts/how-to-set-up-api-gateway-as-a-front-door-for-your-aws-app-runner-service-in-a-vpc-a-practical-guide/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eAWS App Runner makes it incredibly easy to deploy and scale web applications directly from your code repository or container image ‚Äî no infrastructure management required. It‚Äôs a great fit for developers who want simplicity without giving up the power of AWS.\u003c/p\u003e\n\u003cp\u003eBut things start to get tricky when you want to \u003cstrong\u003esecurely connect App Runner to other AWS services inside a private VPC\u003c/strong\u003e ‚Äî especially when you need to expose your backend through \u003cstrong\u003eAmazon API Gateway\u003c/strong\u003e.\u003c/p\u003e","title":"How to Set Up API Gateway as a Front Door for Your AWS App Runner Service in a VPC: A Practical Guide"},{"content":"Introduction When building modern applications, authentication and authorization play a crucial role. Traditionally, these checks happen on the application backend, introducing latency and extra load on your origin servers.\nWith Lambda@Edge, you can run custom auth logic at CloudFront edge locations, stopping unauthorized requests before they ever reach your application or S3 bucket in the first place.\nIn this guide, I‚Äôll walk you through setting up Lambda@Edge to authenticate users, validate JWT tokens issued by Amazon Cognito as a Federated Identity Broker, and handle authorization. This practical, step-by-step approach will help you secure your application globally while keeping latency low by handling authentication and authorization at the edge.\nWhat is Lambda@Edge? Lambda@Edge is an AWS feature that lets you run Lambda functions at CloudFront edge locations worldwide. Instead of processing requests only in a central AWS region, you can intercept and modify requests and responses at the edge ‚Äî reducing latency and enabling dynamic content manipulation functionality.\nWhy Use Lambda@Edge for Authentication \u0026amp; Authorization? Lower Latency: Auth logic runs closer to the user. Offload Origins: Unauthorized requests never hit your S3 bucket or backend. Global Enforcement: CloudFront edge locations enforce the policy everywhere. Flexible Policies: Validate JWT tokens, API keys, or IP allow lists. How Lambda@Edge Works Lambda@Edge integrates with CloudFront and can be triggered during four lifecycle events:\nViewer Request ‚Äì when a user requests to CloudFront. Origin Request ‚Äì before the request is sent to your origin server. Origin Response ‚Äì after the origin sends a response back to CloudFront. Viewer Response ‚Äì before CloudFront responds to the user. In this post, we define the process of authentication and authorization at the Viewer Request stage.\nPrerequisites You\u0026rsquo;ll be needing the following before we dive in, note that this post does not cover how to set up Amazon Cognito with an external Identity Provider (IdP). That configuration is assumed to be already in place.\nAn AWS account that has access to Lambda, CloudFront, S3, Amazon Cognito, and IAM. Basic understanding of AWS Lambda and CloudFront distributions. Amazon Cognito must be configured with an external Identity Provider (IdP), (e.g. Microsoft Entra ID). Amazon Cognito should be capable of issuing valid JWT tokens after authenticating against external IdP. You should already have Amazon Cognito User Pool created. With that foundation, we‚Äôll now focus entirely on how to integrate Lambda@Edge with CloudFront and Amazon Cognito to enforce authentication and authorization.\nArchitecture Overview Before diving into the setup, let‚Äôs look at how authentication and authorization with Lambda@Edge and Amazon Cognito works at a high level.\nFigure 1: High-level architecture of authentication \u0026amp; authorization with Lambda@Edge with Amazon Cognito\nUser Request ‚Üí A user tries to access your application via a CloudFront distribution. Lambda@Edge (Viewer Request) ‚Üí The function intercepts the request before it reaches the origin. Authentication \u0026amp; Authorization ‚Üí Lambda@Edge forwards incoming requests to Amazon Cognito and that will authenticate against an external Identity Provider (IdP). Once the user successfully signs in, Lambda@Edge validates the JWT token issued Amazon Cognito and authorize the request. If no/invalid token ‚Üí the user is redirected to log in again. If valid ‚Üí request continues. Authorized Request ‚Üí Once authenticated and authorized, CloudFront fetches content from the origin S3 bucket. This flow ensures that only authenticated and authorized users can access your content while still benefiting from CloudFront‚Äôs low-latency, globally distributed edge network. Step-by-Step Setup Step 1: Create the IAM role Your Lambda@Edge function needs an execution role with the right permissions and a proper trust relationship.\nIAM Policy (Permissions): Attach the following policy to allow logging to CloudWatch:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Action\u0026#34;: [ \u0026#34;logs:CreateLogGroup\u0026#34;, \u0026#34;logs:CreateLogStream\u0026#34;, \u0026#34;logs:PutLogEvents\u0026#34; ], \u0026#34;Resource\u0026#34;: [ \u0026#34;arn:aws:logs:us-east-1:*:log-group:/aws/lambda/my-lambda-auth-function:*\u0026#34;, \u0026#34;arn:aws:logs:*:*:log-group:/aws/lambda/us-east-1.my-lambda-auth-function:*\u0026#34; ], \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34; }, ] } Name the role something like LambdaEdgeExecutionRole, and attach this policy. If you need your function to call other AWS services (e.g., SSM, Secrets), you‚Äôll have to extend the policy accordingly. Trust Relationship: Use the following trust relationship, so Lambda can assume the role:\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: { \u0026#34;Service\u0026#34;: [ \u0026#34;lambda.amazonaws.com\u0026#34;, \u0026#34;edgelambda.amazonaws.com\u0026#34; ] }, \u0026#34;Action\u0026#34;: \u0026#34;sts:AssumeRole\u0026#34; } ] } Step 2: Create a Lambda Function Go to the AWS Lambda Console in the N. Virginia (us-east-1) region.\nCreate a new function (e.g., MyLambdaAuthFunction).\nChoose runtime Node.js (or Python) and select architecture x86_64.\nAttach the IAM role you created earlier with the name LambdaEdgeExecutionRole.\nUpload the function in the form of a zip file, here is the directory structure:\nnode_modules/ lambda_fucntion.mjs Below is the example code for the auth lambda function:\n// lambda_fucntion.mjs \u0026#39;use strict\u0026#39;; import axios from \u0026#39;axios\u0026#39;; import { decode } from \u0026#39;jsonwebtoken\u0026#39;; const COOKIE_KEY_ID_TOKEN = \u0026#39;id_token\u0026#39;; // I assume you already loaded the values based on your design (e.g., SSM) // Start var cognitoAuthDomain = \u0026#34;YOUR_COGNITO_AUTH_DOMAIN\u0026#34;; // e.g., \u0026lt;YUOR_CUSTOM_DOMAIN\u0026gt;.auth.\u0026lt;REGION\u0026gt;.amazoncognito.com var cognitoClientId = \u0026#34;YOUR_COGNITO_CLIENT_ID\u0026#34;; // Cognito Client ID var redirectURI = \u0026#34;YOUR_REDIRECT_URI\u0026#34;; // Your custom domain e.g., Route53 or CloudFront distribution URL var cognitoIdentityProvider = \u0026#34;YOUR_COGNITO_IDENTITY_PROVIDER\u0026#34;; // Name of Identity provider (type OIDC) // END export async function handler(event) { const request = event.Records[0].cf.request; const token = getCookie(request.headers, COOKIE_KEY_ID_TOKEN); if (token) { // Check if token exists try { if (isTokenExpired(token)) { // Check if the token has expired, attempt to refresh it throw new Error(\u0026#34;Token expired\u0026#34;); } else { return request; // Token is valid, allow the request to pass through } } catch (err) { console.error(\u0026#39;Token validation failed:\u0026#39;, JSON.stringify(err)); return cognitoLoginRedirect(); } } const queryParams = getQueryParams(request.querystring); const state = queryParams.state; const code = queryParams.code; // Check: // 1. If the request contains an authorization code, exchange it for tokens and set them as cookies in the response. // 2. If there is no authorization code, redirect the user to the Cognito login. if (code \u0026amp;\u0026amp; state) { const body = { grant_type: \u0026#39;authorization_code\u0026#39;, code, client_id: cognitoClientId, redirect_uri: redirectURI, }; try { const tokens = await requestCognitoToken(body); return setTokenCookiesAndRedirect(tokens); } catch (err) { console.error(\u0026#39;Error retrieving tokens:\u0026#39;, JSON.stringify(err)); return { status: \u0026#39;500\u0026#39;, statusDescription: \u0026#39;Internal Server Error\u0026#39;, body: \u0026#39;Authentication failed: \u0026#39; + JSON.stringify(err), }; } } else { return cognitoLoginRedirect(); } } function setTokenCookiesAndRedirect(tokens) { const idTokenExp = decode(tokens.id_token, { complete: true }).payload.exp; const expiryInSeconds = idTokenExp ? idTokenExp - Math.floor(Date.now() / 1000) : 86400; // Default to 24 hour if no exp in id_token const expiresString = new Date(Date.now() + expiryInSeconds * 1000).toUTCString(); return { status: \u0026#39;302\u0026#39;, statusDescription: \u0026#39;Found\u0026#39;, headers: { location: [{ key: \u0026#39;Location\u0026#39;, value: redirectURI, }], \u0026#39;set-cookie\u0026#39;: Object.entries(tokens).map(([key, value]) =\u0026gt; { return { key: \u0026#39;Set-Cookie\u0026#39;, value: `${key}=${value}; Domain=${getDomain(redirectURI)}; Secure; Path=/; Max-Age=${expiryInSeconds}; Expires=${expiresString};`, }; }), }, }; } function cognitoLoginRedirect() { const state = getRandomString(32); const queryString = Object.entries({ response_type: \u0026#39;code\u0026#39;, client_id: cognitoClientId, identity_provider: cognitoIdentityProvider, scope: [\u0026#39;openid\u0026#39;, \u0026#39;profile\u0026#39;, \u0026#39;email\u0026#39;].join(\u0026#39; \u0026#39;), redirect_uri: redirectURI, state, }) .map(([k, v]) =\u0026gt; `${encodeURIComponent(k)}=${encodeURIComponent(v)}`) .join(\u0026#39;\u0026amp;\u0026#39;); const response = { status: \u0026#39;302\u0026#39;, statusDescription: \u0026#39;Found\u0026#39;, headers: { location: [{ key: \u0026#39;Location\u0026#39;, value: `https://${cognitoAuthDomain}/oauth2/authorize?${queryString}`, }], }, }; return response; } async function requestCognitoToken(body) { const tokensUrl = `https://${cognitoAuthDomain}/oauth2/token`; try { const response = await axios.post(tokensUrl, body, { headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/x-www-form-urlencoded\u0026#39;, }, }); return response.data; } catch (err) { console.error(\u0026#39;Error fetching tokens:\u0026#39;, JSON.stringify(err)); throw new Error(`Error fetching tokens: ${err.message}`); } } // Below are the utility functions you need to create, as I have skipped them from the block: // // 1. isTokenExpired(token) // ‚Üí Extracts `payload.exp` from the JWT and validates expiry. // // 2. getRandomString(length) // ‚Üí Generates a random alphanumeric string of the given length. // // 3. getQueryParams(queryString) // ‚Üí Parses query parameters from a URL query string into an object. // // 4. getDomain(url) // ‚Üí Extracts the base domain (e.g., example.com) from a full URL. // // 5. getCookie(headers, cookieName) // ‚Üí Extracts the cookie by name from CloudFront request headers. Note: The above code has some redundancies and is written for clarity rather than efficiency. It demonstrates the high-level idea of the authentication and authorization concept with Amazon Cognito and JWT tokens validation. You can optimize it or extend it to support scopes, roles, or custom claims based on your application needs.\nAuthentication \u0026amp; JWT Flow with Lambda@Edge: The following points explain how the request flow works:\nInitial Authentication Request\nThe user accesses your application. Your Lambda@Edge function triggers a request to authenticate the user. The user is redirected to the Identity Provider (IdP) to log in. Receive Authorization Code\nAfter successful login, the IdP returns an authorization code to your application. Exchange Code for JWT Tokens\nYour Lambda function takes the authorization code and requests JWT tokens from Amazon Cognito. Cognito responds with ID token, access token, and refresh token. Store Tokens in Cookie \u0026amp; Redirect\nThe Lambda function stores the received tokens in secure cookies. The user is redirected to the original URL. Subsequent Requests ‚Äì Token Validation\nWhen the user returns, the Lambda@Edge function sees the JWT tokens in the cookies. It validates the tokens to ensure they are authentic and not expired. Once validated, the request is allowed to pass through to your application. Below is the package.json file for the required packages for the lambda function:\n{ \u0026#34;name\u0026#34;: \u0026#34;my_lambda_auth\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;author\u0026#34;: \u0026#34;Yougeshwar Khatri\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;MIT\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Layer for Lambda@Edge function\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;zip\u0026#34;: \u0026#34;rm -rf lambda_content.zip \u0026amp;\u0026amp; zip -r lambda_content.zip ./node_modules ./lambda_function.mjs\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;axios\u0026#34;: \u0026#34;^1.11.0\u0026#34;, \u0026#34;jsonwebtoken\u0026#34;: \u0026#34;^9.0.2\u0026#34; } } Build and Package: Run the following commands to install dependencies and create a zip file for deployment\n# Install project dependencies npm install # Build and create a zip package npm run zip Step 3: Create an S3 Bucket (Origin) Create an S3 bucket (e.g., MyLambdaEdgeAuthBucket). Upload sample files (e.g., index.html). Keep the bucket private. Step 4: Create a CloudFront Distribution Create a new distribution with the name MyDistribution\nSet your S3 bucket as the origin.\nSave the distribution.\nEdit the distribution again to add the behavior\nCreate behavior\nPath pattern: Default (*) Origin: Select S3 bucket origin Viewer protocol policy: Enable Redirect HTTP to HTTPS. Allowed HTTP methods: GET, HEAD, OPTIONS, PUT, POST, PATCH, DELETE Function associations: Viewer request Function type: Lambda@Edge Function ARN with version # It will be updated in next step Step 5: Deploy Lambda@Edge Open your Lambda function in us-east-1. Select Actions ‚Üí Deploy to Lambda@Edge. Attach it to your CloudFront distribution on the Viewer Request event, and that will update the version in CloudFront distribution behavior. Deploy. Step 6: Test Your Setup Testing auth with Amazon Cognito requires a browser flow because tokens are issued after a successful login.\nOpen a browser and access your custom domain or CloudFront URL (e.g., https://d1234abcdef.cloudfront.net/). If the user is not authenticated, the application should redirect them to external IdP login page through Amazon Cognito. After login, Amazon Cognito issues the JWT tokens and redirects back to your CloudFront URL with the tokens included in secure cookies. Lambda@Edge validates the token at the Viewer Request stage: If valid ‚Üí the request passes and content is served. If invalid/expired ‚Üí the user sees a 403 Forbidden response. Logging \u0026amp; Debugging Debugging Lambda@Edge is often tricky, because logs are not tied to the AWS region where your Lambda@Edge is deployed (us-east-1). Instead:\nCloudWatch log groups are always created in request origin region, not in N. Virginia (us-east-1). The log groups appear in the AWS region closest to the request‚Äôs origin (e.g., if a user requests from Germany, logs will be in eu-central-1).\nThe log group follows the naming format:\n/aws/lambda/us-east-1.\u0026lt;function-name\u0026gt; So if your function is called MyLambdaAuthFunction, the logs will be stored in the closest request\u0026rsquo;s origin region under:\n/aws/lambda/us-east-1.MyLambdaAuthFunction Limitations Keep these in mind when designing your auth logic:\nDeployment Region ‚Äì Functions must be created in us-east-1. No Environment Variables ‚Äì Use hard-coded values or versions or SSM. Package Size ‚Äì Max 50 MB uncompressed, 1 MB inline zip. Execution Timeouts ‚Äì 5s for viewer events, 30s for origin events. Runtimes ‚Äì Only Node.js and Python are supported. Architecture ‚Äì Only x86_64 (no ARM/Graviton). File System ‚Äì Read-only /tmp directory, max 512 MB. Limited IAM Access ‚Äì Avoid heavy AWS API calls. Conclusion By moving auth checks to the edge, you:\nBlock unauthorized requests early. Reduce load on your backend. Improve latency and scalability. Lambda@Edge is not a full replacement for centralized identity providers, but it‚Äôs an excellent way to add a first line of defense at the network edge.\nStart small ‚Äî implement a static header check ‚Äî then expand into JWT validation, deeper Cognito integration. Later, you can build on this with the refresh_token concept for more advanced scenarios.\nReferences Below are some useful resources and references that inspired this guide and provide additional context on Lambda@Edge, Amazon Cognito and external IdP (Azure AD) auth process.\nhttps://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/lambda-at-edge-function-restrictions.html https://docs.aws.amazon.com/cognito/latest/developerguide/token-endpoint.html https://docs.aws.amazon.com/cognito/latest/developerguide/federation-endpoints.html https://docs.aws.amazon.com/singlesignon/latest/userguide/how-to-connect-idp.html https://aws.amazon.com/blogs/networking-and-content-delivery/authorizationedge-using-cookies-protect-your-amazon-cloudfront-content-from-being-downloaded-by-unauthenticated-users/ ","permalink":"https://ykhatri.dev/posts/step-by-step-guide-setting-up-lambda-at-edge-for-authentication-and-authorization-with-amazon-cognito/","summary":"\u003ch2 id=\"introduction\"\u003eIntroduction\u003c/h2\u003e\n\u003cp\u003eWhen building modern applications, \u003cstrong\u003eauthentication and authorization\u003c/strong\u003e play a crucial role. Traditionally, these checks happen on the application backend, introducing \u003cstrong\u003elatency\u003c/strong\u003e and extra load on your origin servers.\u003c/p\u003e\n\u003cp\u003eWith \u003cstrong\u003eLambda@Edge\u003c/strong\u003e, you can run custom \u003cstrong\u003eauth logic at CloudFront edge locations\u003c/strong\u003e, stopping unauthorized requests before they ever reach your application or S3 bucket in the first place.\u003c/p\u003e\n\u003cp\u003eIn this guide, I‚Äôll walk you through \u003cstrong\u003esetting up Lambda@Edge to authenticate users, validate JWT tokens issued by Amazon Cognito as a Federated Identity Broker, and handle authorization\u003c/strong\u003e. This practical, step-by-step approach will help you secure your application globally while keeping latency low by handling authentication and authorization at the edge.\u003c/p\u003e","title":"Step-by-Step Guide: Setting Up Lambda@Edge for Authentication \u0026 Authorization with Amazon Cognito"},{"content":" I have been working in the IT industry for over 12 years, specializing in designing and developing scalable cloud-native applications. My expertise lies in leveraging AWS services alongside technologies such as Java, Go, and Spring Boot to create robust and efficient solutions. I hold multiple AWS certifications, including the HashiCorp Certified Terraform Associate, and have earned a master‚Äôs degree in computer science from Germany. Here are my key areas of expertise:\nCloud Industry Expertise (AWS, Azure, GCP) Infrastructure as Code (Terraform, CloudFormation, \u0026amp; AWS CDK) Programming Languages (Java, Go, Node.js, etc.) DevOps Automation \u0026amp; CI/CD Pipelines Cloud Security \u0026amp; Best Practices Containerization \u0026amp; Kubernetes Scalable and Resilient Cloud Architectures You can view my professional certifications here.\nMy professional journey has included collaborations with prominent organizations such as Volkswagen (VW) and MAN Truck \u0026amp; Bus SE, where I contributed to building and optimizing high-performance, cloud-native infrastructures for data-intensive applications. Additionally, I‚Äôve worked with AWS on internal projects, tackling complex challenges and delivering innovative solutions.\nI‚Äôm passionate about microservices architecture and domain-driven design, consistently striving to deliver high-quality, scalable solutions that align with business objectives. With a strong focus on automation and performance, I‚Äôm committed to solving intricate challenges while staying on the cutting edge of technology.\nWhat I‚Äôm Learning I believe in continuous growth and expanding my expertise. Currently, I‚Äôm:\nDeepening my knowledge of Kubernetes and preparing for relevant certifications. Pursuing additional AWS certifications to strengthen my cloud expertise. Enhancing my understanding of Microsoft Azure, focusing on advanced cloud services and architectures. By combining my experience with a dedication to lifelong learning, I aim to deliver innovative solutions that drive business success and exceed expectations. You can reach out me via this contact form here.\n","permalink":"https://ykhatri.dev/about/","summary":"\u003cdiv class=\"image-with-text\"\u003e\n  \u003cdiv class=\"image-container\"\u003e\n    \u003cimg src=\"/images/about-picture.webp\" alt=\"Adventure trip\" /\u003e\n  \u003c/div\u003e\n  \u003cdiv class=\"text-container\"\u003e\n    \nI have been working in the IT industry for over 12 years, specializing in designing and developing scalable cloud-native applications. My expertise lies in leveraging AWS services alongside technologies such as Java, Go, and Spring Boot to create robust and efficient solutions. I hold multiple AWS certifications, including the HashiCorp Certified Terraform Associate, and have earned a master‚Äôs degree in computer science from Germany.\n\n  \u003c/div\u003e\n\u003c/div\u003e\n\n\u003cp\u003eHere are my key areas of expertise:\u003c/p\u003e","title":"About"},{"content":"The certifications listed here reflect my commitment to professional growth and staying current in a fast-evolving industry. While these credentials validate my expertise, they complement hands-on experience gained through real-world application.\nCertifications play a key role in my career by enhancing my skills and providing formal recognition of my proficiency. They serve as a benchmark, demonstrating my ability to apply best practices and stay competitive in my field.\nThese certifications represent both knowledge and practical skills, empowering me to tackle challenges and deliver impactful solutions. Below is a list of my certifications, including issuing organizations, completion dates, and relevant links.\n","permalink":"https://ykhatri.dev/certs/","summary":"\u003cp\u003eThe certifications listed here reflect my commitment to professional growth and staying current in a fast-evolving industry. While these credentials validate my expertise, they complement hands-on experience gained through real-world application.\u003c/p\u003e\n\u003cp\u003eCertifications play a key role in my career by enhancing my skills and providing formal recognition of my proficiency. They serve as a benchmark, demonstrating my ability to apply best practices and stay competitive in my field.\u003c/p\u003e\n\u003cp\u003eThese certifications represent both knowledge and practical skills, empowering me to tackle challenges and deliver impactful solutions. Below is a list of my certifications, including issuing organizations, completion dates, and relevant links.\u003c/p\u003e","title":"Certifications"},{"content":"You can fill the below form to reach out to me:\n","permalink":"https://ykhatri.dev/contact/","summary":"\u003cp\u003eYou can fill the below form to reach out to me:\u003c/p\u003e","title":"Contact"},{"content":"Who I Am Welcome! My name is Yougeshwar Khatri, and this is my personal website. I am committed to protecting your privacy. This Privacy Policy explains what data I collect, how I use it, and your rights regarding your data.\nData Collection This website collects minimal data to ensure your privacy and provide insights to help me improve the site\u0026rsquo;s performance:\nCloudflare Web Analytics: I use Cloudflare Web Analytics to measure traffic and performance on this website. Cloudflare Web Analytics is a privacy-first analytics tool that does not track individual users, use cookies, or collect personal data. Your Privacy I respect your privacy and ensure that no personally identifiable information is collected or stored through this website. The analytics used here are strictly for understanding visitor behavior and improving the content and performance of the site.\nContact Me If you have any questions or concerns about this Privacy Policy, please contact me via contact form.\nUpdates This Privacy Policy was last updated on January 23, 2025.\n","permalink":"https://ykhatri.dev/privacy-policy/","summary":"\u003ch2 id=\"who-i-am\"\u003eWho I Am\u003c/h2\u003e\n\u003cp\u003eWelcome! My name is Yougeshwar Khatri, and this is my personal website. I am committed to protecting your privacy. This Privacy Policy explains what data I collect, how I use it, and your rights regarding your data.\u003c/p\u003e\n\u003ch2 id=\"data-collection\"\u003eData Collection\u003c/h2\u003e\n\u003cp\u003eThis website collects minimal data to ensure your privacy and provide insights to help me improve the site\u0026rsquo;s performance:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eCloudflare Web Analytics\u003c/strong\u003e:\nI use \u003ca href=\"https://www.cloudflare.com/en-gb/web-analytics/\"\u003eCloudflare Web Analytics\u003c/a\u003e to measure traffic and performance on this website. Cloudflare Web Analytics is a privacy-first analytics tool that does not track individual users, use cookies, or collect personal data.\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2 id=\"your-privacy\"\u003eYour Privacy\u003c/h2\u003e\n\u003cp\u003eI respect your privacy and ensure that no personally identifiable information is collected or stored through this website. The analytics used here are strictly for understanding visitor behavior and improving the content and performance of the site.\u003c/p\u003e","title":"Privacy Policy"},{"content":"Terms and Conditions Welcome to ykhatri.dev (the \u0026ldquo;Website\u0026rdquo;). By visiting or using this Website, you agree to follow these Terms and Conditions, as well as all applicable laws and regulations. You are responsible for ensuring that your use complies with local laws. If you do not agree to these terms, please do not use or access this Website.\nAll content on this Website is protected by copyright and other applicable intellectual property laws.\nLimited License You are permitted to temporarily download one copy of the materials (such as information or software) from this Website for personal, non-commercial use only. This license does not transfer ownership, and under this license you may not:\nAlter or copy the content; Use the content for any commercial or public purpose; Attempt to reverse engineer or decompile any software from the Website; Remove copyright or proprietary notices; or Share, distribute, or duplicate the content on another server. This license will automatically end if you break any of these restrictions. Yougeshwar Khatri may also end it at any time. Once the license ends, you must delete or destroy any downloaded content in your possession, whether digital or printed.\nDisclaimer The content on this Website is provided ‚Äúas is.‚Äù Yougeshwar Khatri makes no guarantees or warranties, express or implied, including (but not limited to) warranties of merchantability, fitness for a particular purpose, or non-infringement of intellectual property.\nNo guarantees are made about the accuracy, reliability, or results from the use of the materials on this Website or linked resources.\nLimitation of Liability Yougeshwar Khatri will not be held responsible for any damages that result from the use or inability to use the Website, including but not limited to loss of data, loss of profits, or business interruptions. Even if notified of the possibility of such damages, liability is not accepted.\nSome regions do not allow limitations on liability or implied warranties, so these restrictions may not apply to you.\nAccuracy of Information The content on this Website may sometimes include technical, typographical, or other errors. Yougeshwar Khatri does not guarantee that the content is accurate, complete, or up to date. Content may be updated or changed at any time without prior notice, but there is no obligation to update the materials.\nExternal Links This Website may include links to external websites. Yougeshwar Khatri does not control or review the content on those external sites and is not responsible for them. The inclusion of a link does not mean endorsement, and you use such websites at your own risk.\nChanges to These Terms These Terms and Conditions may be updated or modified at any time without notice. By continuing to use the Website after changes are made, you agree to be bound by the updated version.\nContact Me If you have questions about these Terms and Conditions, you can reach me via contact form.\nUpdates This Terms and Conditions was last updated on August 31, 2025.\n","permalink":"https://ykhatri.dev/terms-and-conditions/","summary":"\u003ch2 id=\"terms-and-conditions\"\u003eTerms and Conditions\u003c/h2\u003e\n\u003cp\u003eWelcome to \u003cstrong\u003eykhatri.dev\u003c/strong\u003e (the \u0026ldquo;Website\u0026rdquo;). By visiting or using this Website, you agree to follow these Terms and Conditions, as well as all applicable laws and regulations. You are responsible for ensuring that your use complies with local laws. If you do not agree to these terms, please do not use or access this Website.\u003c/p\u003e\n\u003cp\u003eAll content on this Website is protected by copyright and other applicable intellectual property laws.\u003c/p\u003e","title":"Terms and Conditions"},{"content":"","permalink":"https://ykhatri.dev/contact-thankyou/","summary":"","title":"Thank you"}]